<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>angular-odata documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">angular-odata documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">
















<ol class="breadcrumb">
  <li class="breadcrumb-item">Classes</li>
  <li class="breadcrumb-item" >ODataModelEvent</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/angular-odata/src/lib/models/options.ts</code>
        </p>






            <section data-compodoc="block-index">
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#bubbles" >bubbles</a>
                            </li>
                            <li>
                                <a href="#chain" >chain</a>
                            </li>
                            <li>
                                    <span class="modifier">Optional</span>
                                <a href="#collection" >collection</a>
                            </li>
                            <li>
                                    <span class="modifier">Optional</span>
                                <a href="#model" >model</a>
                            </li>
                            <li>
                                    <span class="modifier">Optional</span>
                                <a href="#options" >options</a>
                            </li>
                            <li>
                                    <span class="modifier">Optional</span>
                                <a href="#previous" >previous</a>
                            </li>
                            <li>
                                <a href="#type" >type</a>
                            </li>
                            <li>
                                    <span class="modifier">Optional</span>
                                <a href="#value" >value</a>
                            </li>
                        </ul>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Methods</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#canContinueWith" >canContinueWith</a>
                            </li>
                            <li>
                                <a href="#push" >push</a>
                            </li>
                            <li>
                                <a href="#stopPropagation" >stopPropagation</a>
                            </li>
                            <li>
                                <a href="#visited" >visited</a>
                            </li>
                        </ul>
                    </td>
                </tr>





                    <tr>
                        <td class="col-md-4">
                            <h6><b>Accessors</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                    <a href="#path" >path</a>
                                </li>
                                <li>
                                    <a href="#currentModel" >currentModel</a>
                                </li>
                                <li>
                                    <a href="#currentCollection" >currentCollection</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
        </tbody>
    </table>
</section>

            <section data-compodoc="block-constructor">
    <h3 id="constructor">Constructor</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
<code>constructor(type: <a href="../objects/OData.html" target="_self">ODataModelEventType | string</a>, undefined: literal type)</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="55" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:55</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                            <div>
                                    <b>Parameters :</b>
                                    <table class="params">
                                        <thead>
                                            <tr>
                                                <td>Name</td>
                                                    <td>Type</td>
                                                <td>Optional</td>
                                            </tr>
                                        </thead>
                                        <tbody>
                                                <tr>
                                                        <td>type</td>
                                                  
                                                        <td>
                                                                        <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModelEventType | string</a></code>
                                                        </td>
                                                  
                                                    <td>
                                                            No
                                                    </td>
                                                    
                                                </tr>
                                                <tr>
                                                  
                                                        <td>
                                                                    <code>literal type</code>
                                                        </td>
                                                  
                                                    <td>
                                                            No
                                                    </td>
                                                    
                                                </tr>
                                        </tbody>
                                    </table>
                            </div>
                    </td>
                </tr>
            </tbody>
        </table>
</section>

            <section data-compodoc="block-properties">
    
    <h3 id="inputs">
        Properties
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="bubbles"></a>
                    <span class="name">
                        <span ><b>bubbles</b></span>
                        <a href="#bubbles"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="124" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:124</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="chain"></a>
                    <span class="name">
                        <span ><b>chain</b></span>
                        <a href="#chain"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../miscellaneous/functions.html#now" target="_self" >unknown[]</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="97" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:97</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="collection"></a>
                    <span class="name">
                            <span class="modifier">Optional</span>
                        <span ><b>collection</b></span>
                        <a href="#collection"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataCollection&lt;T | ODataModel&lt;T&gt;&gt;</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="160" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:160</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="model"></a>
                    <span class="name">
                            <span class="modifier">Optional</span>
                        <span ><b>model</b></span>
                        <a href="#model"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/ODataModel.html" target="_self" >ODataModel&lt;T&gt;</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="152" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:152</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="options"></a>
                    <span class="name">
                            <span class="modifier">Optional</span>
                        <span ><b>options</b></span>
                        <a href="#options"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="55" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:55</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="previous"></a>
                    <span class="name">
                            <span class="modifier">Optional</span>
                        <span ><b>previous</b></span>
                        <a href="#previous"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="54" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:54</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="type"></a>
                    <span class="name">
                        <span ><b>type</b></span>
                        <a href="#type"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModelEventType | string</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="52" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:52</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="value"></a>
                    <span class="name">
                            <span class="modifier">Optional</span>
                        <span ><b>value</b></span>
                        <a href="#value"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="53" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:53</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
</section>

            <section data-compodoc="block-methods">
    
    <h3 id="methods">
        Methods
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="canContinueWith"></a>
                    <span class="name">
                        <span ><b>canContinueWith</b></span>
                        <a href="#canContinueWith"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>canContinueWith(self: <a href="../objects/OData.html" target="_self">ODataModel&lt;T&gt; | ODataCollection&lt;T | ODataModel&lt;T&gt;&gt;</a>)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="133"
                                    class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:133</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>self</td>
                                            <td>
                                                            <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModel&lt;T&gt; | ODataCollection&lt;T | ODataModel&lt;T&gt;&gt;</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="push"></a>
                    <span class="name">
                        <span ><b>push</b></span>
                        <a href="#push"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>push(model: <a href="../objects/OData.html" target="_self">ODataModel&lt;any&gt; | ODataCollection&lt;any | ODataModel&lt;any&gt;&gt;</a>, attr: <a href="../objects/OData.html" target="_self">ODataModelAttribute&lt;any&gt; | number</a>)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="102"
                                    class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:102</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>model</td>
                                            <td>
                                                            <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModel&lt;any&gt; | ODataCollection&lt;any | ODataModel&lt;any&gt;&gt;</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                        <tr>
                                                <td>attr</td>
                                            <td>
                                                            <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModelAttribute&lt;any&gt; | number</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModelEvent&lt;any&gt;</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="stopPropagation"></a>
                    <span class="name">
                        <span ><b>stopPropagation</b></span>
                        <a href="#stopPropagation"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>stopPropagation()</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="125"
                                    class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:125</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >void</a></code>

                        </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="visited"></a>
                    <span class="name">
                        <span ><b>visited</b></span>
                        <a href="#visited"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>visited(model: <a href="../objects/OData.html" target="_self">ODataModel&lt;any&gt; | ODataCollection&lt;any | ODataModel&lt;any&gt;&gt;</a>)</code>
                </td>
            </tr>


                    <tr>
                        <td class="col-md-4">
                            <div class="io-line">Defined in <a href="" data-line="129"
                                    class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:129</a></div>
                        </td>
                    </tr>


            <tr>
                <td class="col-md-4">

                            <div class="io-description">
                                <b>Parameters :</b>
                                
                                <table class="params">
                                    <thead>
                                        <tr>
                                            <td>Name</td>
                                                <td>Type</td>
                                            <td>Optional</td>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                                <td>model</td>
                                            <td>
                                                            <code><a href="../miscellaneous/variables.html#OData" target="_self" >ODataModel&lt;any&gt; | ODataCollection&lt;any | ODataModel&lt;any&gt;&gt;</a></code>
                                            </td>

                                            <td>
                                                    No
                                            </td>


                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        <div class="io-description">
                            <b>Returns : </b>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                        </div>
                            <div class="io-description">
                                
                            </div>
                </td>
            </tr>
        </tbody>
    </table>
</section>





            <section data-compodoc="block-accessors">
    <h3 id="accessors">
        Accessors
    </h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="path"></a>
                        <span class="name"><b>path</b><a href="#path"><span class="icon ion-ios-link"></span></a></span>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <span class="accessor"><b>get</b><code>path()</code></span>
                    </td>
                </tr>
                            <tr>
                                <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="137" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:137</a></div>
                                </td>
                            </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="currentModel"></a>
                        <span class="name"><b>currentModel</b><a href="#currentModel"><span class="icon ion-ios-link"></span></a></span>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <span class="accessor"><b>get</b><code>currentModel()</code></span>
                    </td>
                </tr>
                            <tr>
                                <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="154" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:154</a></div>
                                </td>
                            </tr>

            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <a name="currentCollection"></a>
                        <span class="name"><b>currentCollection</b><a href="#currentCollection"><span class="icon ion-ios-link"></span></a></span>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <span class="accessor"><b>get</b><code>currentCollection()</code></span>
                    </td>
                </tr>
                            <tr>
                                <td class="col-md-4">
                                    <div class="io-line">Defined in <a href="" data-line="162" class="link-to-prism">projects/angular-odata/src/lib/models/options.ts:162</a></div>
                                </td>
                            </tr>

            </tbody>
        </table>
</section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Observable, Subscription } from &#x27;rxjs&#x27;;
import { finalize } from &#x27;rxjs/operators&#x27;;
import {
  CID_FIELD_NAME,
  COMPUTED,
  DEFAULT_VERSION,
  OPTIMISTIC_CONCURRENCY,
  EVENT_SPLITTER,
} from &#x27;../constants&#x27;;
import { ODataHelper } from &#x27;../helper&#x27;;
import {
  EntityKey,
  ODataQueryOptions,
  ODataQueryOptionsHandler,
  ODataResource,
  ODataSingletonResource,
} from &#x27;../resources&#x27;;
import {
  ODataEntityResource,
  ODataEntitySetResource,
  ODataNavigationPropertyResource,
  ODataPropertyResource,
} from &#x27;../resources&#x27;;
import type {
  ODataEntitySet,
  ODataEnumType,
  ODataStructuredType,
  ODataStructuredTypeFieldParser,
} from &#x27;../schema&#x27;;
import { EdmType, ParserOptions } from &#x27;../types&#x27;;
import { Objects, Types } from &#x27;../utils&#x27;;
import { ODataCollection } from &#x27;./collection&#x27;;
import { ODataModel } from &#x27;./model&#x27;;
import { EventEmitter } from &#x27;@angular/core&#x27;;
import { ODataEntitiesAnnotations, ODataEntityAnnotations } from &#x27;../annotations&#x27;;

export enum ODataModelEventType {
  Change &#x3D; &#x27;change&#x27;,
  Reset &#x3D; &#x27;reset&#x27;,
  Update &#x3D; &#x27;update&#x27;,
  Sort &#x3D; &#x27;sort&#x27;,
  Destroy &#x3D; &#x27;destroy&#x27;,
  Add &#x3D; &#x27;add&#x27;,
  Remove &#x3D; &#x27;remove&#x27;,
  Invalid &#x3D; &#x27;invalid&#x27;,
  Request &#x3D; &#x27;request&#x27;,
  Sync &#x3D; &#x27;sync&#x27;,
  Attach &#x3D; &#x27;attach&#x27;,
}

export class ODataModelEvent&lt;T&gt; {
  type: ODataModelEventType | string;
  value?: any;
  previous?: any;
  options?: any;

  constructor(
    type: ODataModelEventType | string,
    {
      model,
      collection,
      previous,
      value,
      attr,
      options,
      bubbles,
      chain,
    }: {
      model?: ODataModel&lt;T&gt;;
      collection?: ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;;
      attr?: ODataModelAttribute&lt;any&gt; | number;
      previous?: any;
      value?: any;
      options?: any;
      bubbles?: boolean;
      chain?: [
        ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
        ODataModelAttribute&lt;any&gt; | number | null,
      ][];
    } &#x3D; {},
  ) {
    this.type &#x3D; type;
    this.model &#x3D; model;
    this.collection &#x3D; collection;
    this.previous &#x3D; previous;
    this.value &#x3D; value;
    this.options &#x3D; options;
    this.chain &#x3D; chain ?? [
      [
        (this.model || this.collection) as ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
        attr || null,
      ],
    ];
    this.bubbles &#x3D; bubbles ?? BUBBLES.indexOf(this.type) !&#x3D;&#x3D; -1;
  }

  chain: [
    ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
    ODataModelAttribute&lt;any&gt; | number | null,
  ][];

  push(
    model: ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
    attr: ODataModelAttribute&lt;any&gt; | number,
  ) {
    return new ODataModelEvent&lt;any&gt;(this.type, {
      model: this.model ?? (model instanceof ODataModel ? model : undefined),
      collection:
        this.collection ??
        (model instanceof ODataCollection
          ? (model as ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;)
          : undefined),
      previous: this.previous,
      value: this.value,
      options: {
        ...this.options,
        index: attr instanceof ODataModelAttribute ? attr.name : attr,
      },
      bubbles: this.bubbles,
      chain: [[model, attr], ...this.chain],
    });
  }

  bubbles: boolean;
  stopPropagation() {
    this.bubbles &#x3D; false;
  }

  visited(model: ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;) {
    return this.chain.some((c) &#x3D;&gt; c[0] &#x3D;&#x3D;&#x3D; model) &amp;&amp; this.chain[this.chain.length - 1][0] !&#x3D;&#x3D; model;
  }

  canContinueWith(self: ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;) {
    return this.bubbles &amp;&amp; !this.visited(self);
  }

  get path() {
    return this.chain
      .map(([, attr], index) &#x3D;&gt;
        typeof attr &#x3D;&#x3D;&#x3D; &#x27;number&#x27;
          ? &#x60;[${attr}]&#x60;
          : attr instanceof ODataModelAttribute
            ? index &#x3D;&#x3D;&#x3D; 0
              ? attr.name
              : &#x60;.${attr.name}&#x60;
            : &#x27;&#x27;,
      )
      .join(&#x27;&#x27;);
  }

  //Reference to the model which the event was dispatched
  model?: ODataModel&lt;T&gt;;
  //Identifies the current model for the event
  get currentModel(): ODataModel&lt;any&gt; | undefined {
    const link &#x3D; this.chain.find((c) &#x3D;&gt; ODataModelOptions.isModel(c[0]));
    return link !&#x3D;&#x3D; undefined ? (link[0] as ODataModel&lt;any&gt;) : undefined;
  }

  //Reference to the collection which the event was dispatched
  collection?: ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;;
  //Identifies the current collection for the event
  get currentCollection(): ODataCollection&lt;any, ODataModel&lt;any&gt;&gt; | undefined {
    const link &#x3D; this.chain.find((c) &#x3D;&gt; ODataModelOptions.isCollection(c[0]));
    return link !&#x3D;&#x3D; undefined ? (link[0] as ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;) : undefined;
  }
}

export class ODataModelEventEmitter&lt;T&gt; extends EventEmitter&lt;ODataModelEvent&lt;T&gt;&gt; {
  model?: ODataModel&lt;T&gt;;
  collection?: ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;;

  constructor({
    model,
    collection,
  }: {
    model?: ODataModel&lt;T&gt;;
    collection?: ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;;
  } &#x3D; {}) {
    super();
    this.model &#x3D; model;
    this.collection &#x3D; collection;
  }

  trigger(
    type: ODataModelEventType | string,
    {
      collection,
      previous,
      value,
      attr,
      options,
      bubbles,
    }: {
      collection?: ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;;
      attr?: ODataModelAttribute&lt;any&gt; | number;
      previous?: any;
      value?: any;
      options?: any;
      bubbles?: boolean;
    } &#x3D; {},
  ) {
    const _trigger &#x3D; (name: string) &#x3D;&gt;
      this.emit(
        new ODataModelEvent(name, {
          model: this.model,
          collection: collection ?? this.collection,
          previous,
          value,
          attr,
          options,
          bubbles,
        }),
      );
    if (type &amp;&amp; EVENT_SPLITTER.test(type)) {
      for (const name of type.split(EVENT_SPLITTER)) {
        _trigger(name);
      }
    } else {
      _trigger(type);
    }
  }
}

export const BUBBLES: (ODataModelEventType | string)[] &#x3D; [
  ODataModelEventType.Change,
  ODataModelEventType.Reset,
  ODataModelEventType.Update,
  ODataModelEventType.Destroy,
  ODataModelEventType.Add,
  ODataModelEventType.Remove,
];

export const INCLUDE_SHALLOW &#x3D; {
  include_concurrency: true,
  include_computed: true,
  include_key: true,
  include_id: false,
};

export const INCLUDE_DEEP &#x3D; {
  include_navigation: true,
  include_non_field: true,
  ...INCLUDE_SHALLOW,
};

export enum ODataModelState {
  Added,
  Removed,
  Changed,
  Unchanged,
}

export type ModelInterface&lt;T&gt; &#x3D; {
  [P in keyof T]: T[P] extends (infer U)[]
    ? ODataCollection&lt;U, ODataModel&lt;U&gt; &amp; ModelInterface&lt;U&gt;&gt;
    : T[P] extends object
      ? ODataModel&lt;T[P]&gt; &amp; ModelInterface&lt;T[P]&gt;
      : T[P];
};

export type ModelOptions &#x3D; {
  cid?: string;
  fields: Map&lt;string, ModelFieldOptions&gt;;
};

export type ModelFieldOptions &#x3D; {
  field?: string;
  parser?: ODataStructuredTypeFieldParser&lt;any&gt;;
  default?: any;
  required?: boolean;
  concurrency?: boolean;
  maxLength?: number;
  minLength?: number;
  min?: number;
  max?: number;
  pattern?: RegExp;
};

export function Model({ cid &#x3D; CID_FIELD_NAME }: { cid?: string } &#x3D; {}) {
  return &lt;T extends { new (...args: any[]): {} }&gt;(constructor: T) &#x3D;&gt; {
    const Klass &#x3D; &lt;any&gt;constructor;
    if (!Klass.hasOwnProperty(&#x27;options&#x27;))
      Klass.options &#x3D; {
        fields: new Map&lt;string, ModelFieldOptions&gt;(),
      } as ModelOptions;
    Klass.options.cid &#x3D; cid;
    return constructor;
  };
}

export function ModelField({ name, ...options }: { name?: string } &amp; ModelFieldOptions &#x3D; {}) {
  return (target: any, key: string): void &#x3D;&gt; {
    const Klass &#x3D; target.constructor;
    if (!Klass.hasOwnProperty(&#x27;options&#x27;))
      Klass.options &#x3D; {
        fields: new Map&lt;string, ModelFieldOptions&gt;(),
      } as ModelOptions;
    options.field &#x3D; name ?? key;
    Klass.options.fields.set(key, options);
  };
}

export type ODataModelFieldOptions&lt;F&gt; &#x3D; ModelFieldOptions &amp; {
  name: string;
  field: string;
  parser: ODataStructuredTypeFieldParser&lt;F&gt;;
};

export class ODataModelField&lt;F&gt; {
  name: string;
  field: string;
  parser: ODataStructuredTypeFieldParser&lt;F&gt;;
  options: ODataModelOptions&lt;any&gt;;
  optionsForType?: (type: string) &#x3D;&gt; ODataModelOptions&lt;any&gt; | undefined;
  modelForType?: (t: string) &#x3D;&gt; typeof ODataModel&lt;any&gt; | undefined;
  collectionForType?: (t: string) &#x3D;&gt; typeof ODataCollection&lt;any, ODataModel&lt;any&gt;&gt; | undefined;
  enumForType?: (t: string) &#x3D;&gt; ODataEnumType&lt;F&gt; | undefined;
  structuredForType?: (t: string) &#x3D;&gt; ODataStructuredType&lt;F&gt; | undefined;
  default?: any;
  required: boolean;
  concurrency: boolean;
  maxLength?: number;
  minLength?: number;
  min?: number;
  max?: number;
  pattern?: RegExp;
  parserOptions?: ParserOptions;

  constructor(
    options: ODataModelOptions&lt;any&gt;,
    { name, field, parser, ...opts }: ODataModelFieldOptions&lt;F&gt;,
  ) {
    this.options &#x3D; options;
    this.name &#x3D; name;
    this.field &#x3D; field;
    this.parser &#x3D; parser;
    this.default &#x3D; opts.default || parser.default;
    this.required &#x3D; Boolean(opts.required || !parser.nullable);
    this.concurrency &#x3D; Boolean(opts.concurrency);
    this.maxLength &#x3D; opts.maxLength || parser.maxLength;
    this.minLength &#x3D; opts.minLength;
    this.min &#x3D; opts.min;
    this.max &#x3D; opts.max;
    this.pattern &#x3D; opts.pattern;
  }

  get type() {
    return this.parser.type;
  }

  get navigation() {
    return this.parser.navigation;
  }

  get collection() {
    return this.parser.collection;
  }

  annotatedValue&lt;T&gt;(term: string | RegExp) {
    return this.parser.annotatedValue&lt;T&gt;(term);
  }

  configure({
    optionsForType,
    modelForType,
    collectionForType,
    enumForType,
    structuredForType,
    concurrency,
    options,
  }: {
    optionsForType: (type: string) &#x3D;&gt; ODataModelOptions&lt;any&gt; | undefined;
    modelForType: (t: string) &#x3D;&gt; typeof ODataModel&lt;any&gt; | undefined;
    collectionForType: (t: string) &#x3D;&gt; typeof ODataCollection&lt;any, any&gt; | undefined;
    enumForType: (t: string) &#x3D;&gt; ODataEnumType&lt;any&gt; | undefined;
    structuredForType: (t: string) &#x3D;&gt; ODataStructuredType&lt;any&gt; | undefined;
    concurrency: boolean;
    options: ParserOptions;
  }) {
    this.optionsForType &#x3D; optionsForType;
    this.modelForType &#x3D; modelForType;
    this.collectionForType &#x3D; collectionForType;
    this.enumForType &#x3D; enumForType;
    this.structuredForType &#x3D; structuredForType;
    this.parserOptions &#x3D; options;
    if (concurrency) this.concurrency &#x3D; concurrency;
    if (this.default !&#x3D;&#x3D; undefined) this.default &#x3D; this.deserialize(this.default, options);
  }

  isKey() {
    return this.parser.isKey();
  }

  hasReferentials() {
    return this.parser.hasReferentials();
  }

  get referentials() {
    return this.parser.referentials;
  }

  isStructuredType() {
    return this.parser.isStructuredType();
  }

  structuredType() {
    const structuredType &#x3D; this.structuredForType ? this.structuredForType(this.type) : undefined;
    //Throw error if not found
    if (!structuredType) throw new Error(&#x60;Could not find structured type for ${this.parser.type}&#x60;);
    return structuredType;
  }

  isEnumType() {
    return this.parser.isEnumType();
  }

  enumType() {
    const enumType &#x3D; this.enumForType ? this.enumForType(this.type) : undefined;
    //Throw error if not found
    if (!enumType) throw new Error(&#x60;Could not find enum type for ${this.parser.type}&#x60;);
    return enumType;
  }

  validate(
    value: any,
    {
      method,
      navigation &#x3D; false,
    }: {
      method?: &#x27;create&#x27; | &#x27;update&#x27; | &#x27;modify&#x27;;
      navigation?: boolean;
    } &#x3D; {},
  ) {
    if (ODataModelOptions.isModel(value)) {
      return !value.isValid({ method, navigation }) ? value._errors : undefined;
    } else if (ODataModelOptions.isCollection(value)) {
      return value.models().some((m: ODataModel&lt;any&gt;) &#x3D;&gt; !m.isValid({ method, navigation }))
        ? value.models().map((m: ODataModel&lt;any&gt;) &#x3D;&gt; m._errors)
        : undefined;
    } else {
      const computed &#x3D; this.annotatedValue&lt;boolean&gt;(COMPUTED);
      const errors &#x3D; this.parser?.validate(value, { method, navigation }) || [];
      if (
        this.required &amp;&amp;
        (value &#x3D;&#x3D;&#x3D; null || (value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; method !&#x3D;&#x3D; &#x27;modify&#x27;)) &amp;&amp; // Is null or undefined without patch?
        !(computed &amp;&amp; method &#x3D;&#x3D;&#x3D; &#x27;create&#x27;) // Not (Is Computed field and create) ?
      ) {
        errors[&#x27;push&#x27;](&#x60;required&#x60;);
      }
      if (
        this.maxLength !&#x3D;&#x3D; undefined &amp;&amp;
        typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp;
        value.length &gt; this.maxLength
      ) {
        errors[&#x27;push&#x27;](&#x60;maxlength&#x60;);
      }
      if (
        this.minLength !&#x3D;&#x3D; undefined &amp;&amp;
        typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp;
        value.length &lt; this.minLength
      ) {
        errors[&#x27;push&#x27;](&#x60;minlength&#x60;);
      }
      if (this.min !&#x3D;&#x3D; undefined &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; value &lt; this.min) {
        errors[&#x27;push&#x27;](&#x60;min&#x60;);
      }
      if (this.max !&#x3D;&#x3D; undefined &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; value &gt; this.max) {
        errors[&#x27;push&#x27;](&#x60;max&#x60;);
      }
      if (this.pattern !&#x3D;&#x3D; undefined &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; !this.pattern.test(value)) {
        errors[&#x27;push&#x27;](&#x60;pattern&#x60;);
      }
      return !Types.isEmpty(errors) ? errors : undefined;
    }
  }

  defaults(): any {
    const meta &#x3D; this.optionsForType ? this.optionsForType(this.type) : undefined;
    return this.isStructuredType() &amp;&amp; meta !&#x3D;&#x3D; undefined ? meta.defaults() : this.default;
  }

  deserialize(value: any, options?: ParserOptions): F | F[] {
    const parserOptions &#x3D; options ?? this.parserOptions;
    return this.parser.deserialize(value, parserOptions);
  }

  serialize(value: F, options?: ParserOptions): any {
    const parserOptions &#x3D; options ?? this.parserOptions;
    return this.parser.serialize(value, parserOptions);
  }

  encode(value: F, options?: ParserOptions): any {
    const parserOptions &#x3D; options ?? this.parserOptions;
    return this.parser.encode(value, parserOptions);
  }

  resourceFactory&lt;T, F&gt;(
    base: ODataResource&lt;T&gt;,
  ): ODataNavigationPropertyResource&lt;F&gt; | ODataPropertyResource&lt;F&gt; {
    if (
      !(
        base instanceof ODataEntityResource ||
        base instanceof ODataNavigationPropertyResource ||
        base instanceof ODataPropertyResource
      )
    )
      throw new Error(&quot;Can&#x27;t build resource for non compatible base type&quot;);
    return this.navigation
      ? (base as ODataEntityResource&lt;T&gt;).navigationProperty&lt;F&gt;(this.parser.name)
      : (base as ODataEntityResource&lt;T&gt;).property&lt;F&gt;(this.parser.name);
  }

  annotationsFactory&lt;T, F&gt;(
    base: ODataEntityAnnotations&lt;T&gt;,
  ): ODataEntityAnnotations&lt;F&gt; | ODataEntitiesAnnotations&lt;F&gt; {
    return this.parser.collection
      ? base.property(this.parser.name as keyof T, &#x27;collection&#x27;)
      : base.property(this.parser.name as keyof T, &#x27;single&#x27;);
  }

  modelFactory&lt;F&gt;({
    parent,
    value,
    reset,
  }: {
    parent: ODataModel&lt;any&gt;;
    value?: Partial&lt;F&gt; | { [name: string]: any };
    reset?: boolean;
  }): ODataModel&lt;F&gt; {
    // Model
    const annots &#x3D; this.annotationsFactory(parent.annots()) as ODataEntityAnnotations&lt;F&gt;;
    let Model &#x3D; this.modelForType ? this.modelForType(this.type) : undefined;
    if (Model &#x3D;&#x3D;&#x3D; undefined) throw Error(&#x60;No Model type for ${this.name}&#x60;);
    if (value !&#x3D;&#x3D; undefined) {
      annots.update(value);
    }

    if (annots?.type !&#x3D;&#x3D; undefined &amp;&amp; Model.meta !&#x3D;&#x3D; null) {
      const meta &#x3D; Model.meta.findChildOptions((o) &#x3D;&gt;
        o.isTypeOf(annots.type as string),
      )?.structuredType;
      if (meta !&#x3D;&#x3D; undefined &amp;&amp; meta.model !&#x3D;&#x3D; undefined)
        // Change to child model
        Model &#x3D; meta.model;
    }

    return new Model((value || {}) as Partial&lt;F&gt; | { [name: string]: any }, {
      annots,
      reset,
      parent: [parent, this],
    }) as ODataModel&lt;F&gt;;
  }

  collectionFactory&lt;F&gt;({
    parent,
    value,
    reset,
  }: {
    parent: ODataModel&lt;any&gt;;
    value?: Partial&lt;F&gt;[] | { [name: string]: any }[];
    reset?: boolean;
  }): ODataCollection&lt;F, ODataModel&lt;F&gt;&gt; {
    // Collection Factory
    const annots &#x3D; this.annotationsFactory(parent.annots()) as ODataEntitiesAnnotations&lt;F&gt;;
    const Collection &#x3D; this.collectionForType ? this.collectionForType(this.type) : undefined;
    if (Collection &#x3D;&#x3D;&#x3D; undefined) throw Error(&#x60;No Collection type for ${this.name}&#x60;);
    return new Collection((value || []) as Partial&lt;F&gt;[] | { [name: string]: any }[], {
      annots: annots,
      reset,
      parent: [parent, this],
    }) as ODataCollection&lt;F, ODataModel&lt;F&gt;&gt;;
  }
}

export class ODataModelAttribute&lt;T&gt; {
  private state: ODataModelState &#x3D; ODataModelState.Unchanged;
  private value?: T | ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt; | null;
  private change?: T | ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt; | null;
  private subscription?: Subscription;
  events$ &#x3D; new ODataModelEventEmitter&lt;T&gt;();

  constructor(
    private _model: ODataModel&lt;any&gt;,
    private _field: ODataModelField&lt;T&gt;,
  ) {}

  get type() {
    return this._field.type;
  }

  get navigation() {
    return this._field.navigation;
  }

  get computed() {
    return this._field.annotatedValue&lt;boolean&gt;(COMPUTED);
  }

  get concurrency() {
    return Boolean(this._field.concurrency);
  }

  get referentials() {
    return this._field.referentials;
  }

  get options() {
    return this._field.options;
  }

  get name() {
    return this._field.name;
  }

  get fieldName() {
    return this._field.field;
  }

  get(): T | ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt; | null | undefined {
    return this.state &#x3D;&#x3D;&#x3D; ODataModelState.Changed ? this.change : this.value;
  }

  set(
    value: T | ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt; | null | undefined,
    reset: boolean &#x3D; false,
    reparent: boolean &#x3D; false,
  ) {
    const current &#x3D; this.get();

    if (ODataModelOptions.isModel(current) || ODataModelOptions.isCollection(current))
      this.unlink(
        current as ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;,
        //this.value !&#x3D;&#x3D; current
      );

    const changed &#x3D;
      ODataModelOptions.isModel(current) &amp;&amp; ODataModelOptions.isModel(value)
        ? !(current as ODataModel&lt;T&gt;).equals(value as ODataModel&lt;T&gt;)
        : ODataModelOptions.isCollection(current) &amp;&amp; ODataModelOptions.isCollection(value)
          ? !(current as ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;).equals(
              value as ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;,
            )
          : !Types.isEqual(current, value);
    if (reset) {
      this.value &#x3D; value;
      this.state &#x3D; ODataModelState.Unchanged;
    } else if (Types.isEqual(value, this.value)) {
      this.state &#x3D; ODataModelState.Unchanged;
    } else if (changed) {
      this.change &#x3D; value;
      this.state &#x3D; ODataModelState.Changed;
    }
    if (ODataModelOptions.isModel(value) || ODataModelOptions.isCollection(value)) {
      this.link(value as ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;, reparent);
    }
    return changed;
  }

  isChanged({ include_navigation &#x3D; false }: { include_navigation?: boolean } &#x3D; {}): boolean {
    const current &#x3D; this.get();
    return (
      this.state &#x3D;&#x3D;&#x3D; ODataModelState.Changed ||
      ((ODataModelOptions.isModel(current) || ODataModelOptions.isCollection(current)) &amp;&amp;
        (current as ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;).hasChanged({
          include_navigation,
        }))
    );
  }

  reset() {
    if (ODataModelOptions.isModel(this.change) || ODataModelOptions.isCollection(this.change))
      this.unlink(this.change as ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;);
    this.state &#x3D; ODataModelState.Unchanged;
    if (ODataModelOptions.isModel(this.value) || ODataModelOptions.isCollection(this.value))
      this.link(this.value as ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;);
  }

  private link(
    value: ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;,
    reparent: boolean &#x3D; false,
  ) {
    this.subscription &#x3D; value.events$.subscribe((e) &#x3D;&gt; this.events$.emit(e));
    if (reparent) {
      value._parent &#x3D; [this._model, this._field];
    }
  }

  private unlink(
    value: ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;,
    reparent: boolean &#x3D; false,
  ) {
    this.subscription?.unsubscribe();
    this.subscription &#x3D; undefined;
    if (reparent) {
      value._parent &#x3D; null;
    }
  }
}

export type ODataModelEntry&lt;T, M extends ODataModel&lt;T&gt;&gt; &#x3D; {
  state: ODataModelState;
  model: M;
  key?: EntityKey&lt;T&gt; | { [name: string]: any };
  subscription?: Subscription;
};

export class ODataModelOptions&lt;T&gt; {
  name: string;
  cid: string;
  base?: string;
  private _fields: ODataModelField&lt;any&gt;[] &#x3D; [];
  structuredType: ODataStructuredType&lt;T&gt;;
  entitySet?: ODataEntitySet;
  // Hierarchy
  parent?: ODataModelOptions&lt;any&gt;;
  children: ODataModelOptions&lt;any&gt;[] &#x3D; [];
  events$ &#x3D; new ODataModelEventEmitter&lt;T&gt;();

  constructor({
    config,
    structuredType,
  }: {
    config: ModelOptions;
    structuredType: ODataStructuredType&lt;T&gt;;
  }) {
    this.name &#x3D; structuredType.name;
    this.base &#x3D; structuredType.base;
    this.structuredType &#x3D; structuredType;
    this.cid &#x3D; config?.cid ?? CID_FIELD_NAME;
    config.fields.forEach((value, key) &#x3D;&gt; this.addField&lt;any&gt;(key, value));
  }

  get api() {
    return this.structuredType.api;
  }

  type({ alias &#x3D; false }: { alias?: boolean } &#x3D; {}) {
    return this.structuredType.type({ alias });
  }

  isOpenType() {
    return this.structuredType.isOpenType();
  }

  isEntityType() {
    return this.structuredType.isEntityType();
  }

  isComplexType() {
    return this.structuredType.isComplexType();
  }

  isTypeOf(type: string) {
    return this.structuredType.type() &#x3D;&#x3D;&#x3D; type;
  }

  isModelFor(entity: T | { [name: string]: any }) {
    // Resolve By Type
    const type &#x3D; this.api.options.helper.type(entity as { [name: string]: any });
    if (type &amp;&amp; this.isTypeOf(type)) return true;
    // Resolve By fields
    const keys &#x3D; Object.keys(entity as { [name: string]: any });
    const names &#x3D; this.fields({
      include_navigation: true,
      include_parents: true,
    }).map((f) &#x3D;&gt; f.name);
    return keys.every((key) &#x3D;&gt; names.includes(key));
  }

  findChildOptions(
    predicate: (options: ODataModelOptions&lt;any&gt;) &#x3D;&gt; boolean,
  ): ODataModelOptions&lt;any&gt; | undefined {
    if (predicate(this)) return this;
    let match: ODataModelOptions&lt;any&gt; | undefined;
    for (const ch of this.children) {
      match &#x3D; ch.findChildOptions(predicate);
      if (match !&#x3D;&#x3D; undefined) break;
    }
    return match;
  }

  configure({ options }: { options: ParserOptions }) {
    if (this.base) {
      const parent &#x3D; this.api.optionsForType(this.base) as ODataModelOptions&lt;any&gt;;
      parent.children.push(this);
      this.parent &#x3D; parent;
    }
    this.entitySet &#x3D; this.api.findEntitySetForEntityType(this.type());
    let concurrencyFields: string[] &#x3D; [];
    if (this.entitySet !&#x3D;&#x3D; undefined) {
      concurrencyFields &#x3D; this.entitySet.annotatedValue&lt;string[]&gt;(OPTIMISTIC_CONCURRENCY) || [];
    }
    this._fields.forEach((field) &#x3D;&gt; {
      const concurrency &#x3D; concurrencyFields.indexOf(field.field) !&#x3D;&#x3D; -1;
      field.configure({
        optionsForType: (t: string) &#x3D;&gt; this.api.optionsForType(t),
        modelForType: (t: string) &#x3D;&gt; this.api.modelForType(t),
        collectionForType: (t: string) &#x3D;&gt; this.api.collectionForType(t),
        enumForType: (t: string) &#x3D;&gt; this.api.findEnumType(t),
        structuredForType: (t: string) &#x3D;&gt; this.api.findStructuredType(t),
        concurrency,
        options,
      });
    });
  }

  fields({
    include_navigation,
    include_parents,
  }: {
    include_parents: boolean;
    include_navigation: boolean;
  }): ODataModelField&lt;any&gt;[] {
    return [
      ...(include_parents &amp;&amp; this.parent !&#x3D;&#x3D; undefined
        ? this.parent.fields({ include_navigation, include_parents })
        : []),
      ...this._fields.filter((field) &#x3D;&gt; include_navigation || !field.navigation),
    ];
  }

  field&lt;F&gt;(name: keyof T | string) {
    const field &#x3D; this.findField&lt;F&gt;(name);
    //Throw error if not found
    if (!field) throw new Error(&#x60;No field with name ${name as string}&#x60;);
    return field as ODataModelField&lt;F&gt;;
  }

  findField&lt;F&gt;(
    name: keyof T | string,
    { reset }: { reset?: boolean } &#x3D; {},
  ): ODataModelField&lt;F&gt; | undefined {
    return this.fields({
      include_parents: true,
      include_navigation: true,
    }).find(
      (modelField: ODataModelField&lt;F&gt;) &#x3D;&gt;
        (reset &amp;&amp; modelField.field &#x3D;&#x3D;&#x3D; name) || modelField.name &#x3D;&#x3D;&#x3D; name,
    ) as ODataModelField&lt;F&gt; | undefined;
  }

  addField&lt;F&gt;(name: string, options: ModelFieldOptions) {
    const { field, parser, ...opts } &#x3D; options;
    if (field &#x3D;&#x3D;&#x3D; undefined || name &#x3D;&#x3D;&#x3D; undefined)
      throw new Error(&#x27;Model Properties need name and field&#x27;);
    const fieldParser &#x3D; parser ?? this.structuredType.field&lt;F&gt;(field as keyof T);
    if (fieldParser &#x3D;&#x3D;&#x3D; undefined) throw new Error(&#x60;No parser for ${field} with name &#x3D; ${name}&#x60;);
    const modelField &#x3D; new ODataModelField&lt;F&gt;(this, {
      name,
      field,
      parser: fieldParser,
      ...opts,
    });
    this._fields.push(modelField);
    return modelField;
  }

  tsToEdm: Record&lt;string, EdmType&gt; &#x3D; {
    string: EdmType.String,
    number: EdmType.Int32,
    bigint: EdmType.Int64,
    boolean: EdmType.Boolean,
  };
  private modelFieldFactory&lt;F&gt;(self: ODataModel&lt;T&gt;, name: string, type: EdmType | string) {
    const structuredFieldParser &#x3D; this.structuredType.addField&lt;F&gt;(name, {
      type,
    });
    structuredFieldParser.configure({
      parserForType: (type: EdmType | string) &#x3D;&gt; this.api.parserForType(type),
      options: this.api.options,
    });
    const modelField &#x3D; this.addField&lt;F&gt;(name, {
      field: name,
      parser: structuredFieldParser,
    });
    modelField.configure({
      optionsForType: (t: string) &#x3D;&gt; this.api.optionsForType(t),
      modelForType: (t: string) &#x3D;&gt; this.api.modelForType(t),
      collectionForType: (t: string) &#x3D;&gt; this.api.collectionForType(t),
      enumForType: (t: string) &#x3D;&gt; this.api.findEnumType(t),
      structuredForType: (t: string) &#x3D;&gt; this.api.findStructuredType(t),
      options: this.api.options,
      concurrency: false,
    });
    Object.defineProperty(self, modelField.name, {
      configurable: true,
      get: () &#x3D;&gt; this.get(self, modelField as ODataModelField&lt;any&gt;),
      set: (value: any) &#x3D;&gt; this.set(self, modelField as ODataModelField&lt;any&gt;, value),
    });
    return modelField;
  }

  attach(
    self: ODataModel&lt;T&gt;,
    resource:
      | ODataEntityResource&lt;T&gt;
      | ODataNavigationPropertyResource&lt;T&gt;
      | ODataPropertyResource&lt;T&gt;
      | ODataSingletonResource&lt;T&gt;,
  ) {
    if (
      self._resource !&#x3D;&#x3D; null &amp;&amp;
      resource.outgoingType() !&#x3D;&#x3D; self._resource.outgoingType() &amp;&amp;
      !self._resource.isSubtypeOf(resource)
    )
      throw new Error(
        &#x60;Can&#x27;t attach ${resource.outgoingType()} to ${self._resource.outgoingType()}&#x60;,
      );

    const current &#x3D; self._resource;
    if (current &#x3D;&#x3D;&#x3D; null || !current.isEqualTo(resource)) {
      self._resource &#x3D; resource;
      self.events$.trigger(ODataModelEventType.Attach, {
        previous: current,
        value: resource,
      });
    }
  }

  //# region Resource
  static chain(
    child: ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
  ): [ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;, ODataModelField&lt;any&gt; | null][] {
    const chain &#x3D; [] as any[];
    let tuple:
      | [ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;, ODataModelField&lt;any&gt; | null]
      | null &#x3D; [child, null];
    while (tuple !&#x3D;&#x3D; null) {
      const parent &#x3D; tuple as [
        ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
        ODataModelField&lt;any&gt; | null,
      ];
      if (chain.some((p) &#x3D;&gt; p[0] &#x3D;&#x3D;&#x3D; parent[0])) break;
      chain.splice(0, 0, parent);
      tuple &#x3D; tuple[0]._parent;
    }
    return chain;
  }

  static resource&lt;T&gt;(
    child: ODataModel&lt;T&gt; | ODataCollection&lt;T, ODataModel&lt;T&gt;&gt;,
  ): ODataResource&lt;T&gt; | null {
    let resource: ODataResource&lt;any&gt; | null &#x3D; null;
    let prevField: ODataModelField&lt;any&gt; | null &#x3D; null;
    for (const [model, field] of ODataModelOptions.chain(child)) {
      resource &#x3D; resource || (model._resource as ODataResource&lt;T&gt;);
      if (resource &#x3D;&#x3D;&#x3D; null) break;
      if (ODataModelOptions.isModel(model) &amp;&amp; (prevField &#x3D;&#x3D;&#x3D; null || prevField.collection)) {
        const m &#x3D; model as ODataModel&lt;any&gt;;
        // Resolve subtype if collection not is from field
        // FIXME
        /*
        if (field &#x3D;&#x3D;&#x3D; null) {
          const r &#x3D; m._meta.modelResourceFactory(resource.cloneQuery&lt;T&gt;());
          if (r !&#x3D;&#x3D; null &amp;&amp; !r.isTypeOf(resource) &amp;&amp; r.isSubtypeOf(resource)) {
            resource &#x3D; r;
          }
        }
        */
        // Resolve key
        const mKey &#x3D; m.key({ field_mapping: true }) as EntityKey&lt;any&gt;;
        if (mKey !&#x3D;&#x3D; undefined) {
          resource &#x3D;
            resource instanceof ODataEntitySetResource
              ? resource.entity(mKey)
              : (resource as ODataEntityResource&lt;T&gt;).key(mKey);
        }
      }
      prevField &#x3D; field;
      if (field &#x3D;&#x3D;&#x3D; null &amp;&amp; model._resource !&#x3D;&#x3D; null) {
        // Apply the query from model to new resource
        model._resource.query((qs) &#x3D;&gt; resource?.query((qd) &#x3D;&gt; qd.restore(qs.store())));
      } else if (field !&#x3D;&#x3D; null) {
        resource &#x3D; field.resourceFactory&lt;any, any&gt;(resource);
      }
    }
    return resource;
  }

  collectionResourceFactory(
    query?: ODataQueryOptions&lt;T&gt;,
  ):
    | ODataEntitySetResource&lt;T&gt;
    | ODataNavigationPropertyResource&lt;T&gt;
    | ODataPropertyResource&lt;T&gt;
    | null {
    if (this.entitySet &#x3D;&#x3D;&#x3D; undefined) return null;
    return ODataEntitySetResource.factory&lt;T&gt;(this.api, {
      path: this.entitySet.name,
      type: this.entitySet.entityType,
      query,
    });
  }

  modelResourceFactory(
    query?: ODataQueryOptions&lt;T&gt;,
  ):
    | ODataEntityResource&lt;T&gt;
    | ODataNavigationPropertyResource&lt;T&gt;
    | ODataPropertyResource&lt;T&gt;
    | ODataSingletonResource&lt;T&gt;
    | null {
    const resource &#x3D; this.collectionResourceFactory(query);
    if (resource instanceof ODataEntitySetResource) return resource.entity();
    return resource as
      | ODataEntityResource&lt;T&gt;
      | ODataNavigationPropertyResource&lt;T&gt;
      | ODataPropertyResource&lt;T&gt;
      | ODataSingletonResource&lt;T&gt;
      | null;
  }
  //#endregion

  bind(
    self: ODataModel&lt;T&gt;,
    {
      parent,
      resource,
      annots,
    }: {
      parent?: [
        ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;,
        ODataModelField&lt;any&gt; | null,
      ];
      resource?: ODataResource&lt;T&gt; | null;
      annots?: ODataEntityAnnotations&lt;T&gt;;
    } &#x3D; {},
  ) {
    // Events
    self.events$.subscribe((e) &#x3D;&gt; this.events$.emit(e));

    // Parent
    if (parent !&#x3D;&#x3D; undefined) {
      self._parent &#x3D; parent;
    }

    // Resource
    if (self._parent &#x3D;&#x3D;&#x3D; null &amp;&amp; resource &#x3D;&#x3D;&#x3D; undefined) resource &#x3D; this.modelResourceFactory();
    if (resource) {
      this.attach(
        self,
        resource as
          | ODataEntityResource&lt;T&gt;
          | ODataPropertyResource&lt;T&gt;
          | ODataNavigationPropertyResource&lt;T&gt;
          | ODataSingletonResource&lt;T&gt;,
      );
    }

    // Annotations
    self._annotations &#x3D; annots ?? new ODataEntityAnnotations(ODataHelper[DEFAULT_VERSION]);

    // Fields
    this.fields({
      include_navigation: true,
      include_parents: true,
    }).forEach((field) &#x3D;&gt; {
      Object.defineProperty(self, field.name, {
        configurable: true,
        get: () &#x3D;&gt; this.get(self, field as ODataModelField&lt;any&gt;),
        set: (value: any) &#x3D;&gt; this.set(self, field as ODataModelField&lt;any&gt;, value),
      });
    });
  }

  query(
    self: ODataModel&lt;T&gt;,
    resource:
      | ODataEntityResource&lt;T&gt;
      | ODataPropertyResource&lt;T&gt;
      | ODataNavigationPropertyResource&lt;T&gt;
      | ODataSingletonResource&lt;T&gt;,
    func: (q: ODataQueryOptionsHandler&lt;T&gt;, s?: ODataStructuredType&lt;T&gt;) &#x3D;&gt; void,
  ) {
    resource.query(func);
    this.attach(self, resource);
    return self;
  }

  resolveKey(
    value: ODataModel&lt;T&gt; | T | { [name: string]: any },
    {
      field_mapping &#x3D; false,
      resolve &#x3D; true,
      single &#x3D; true,
    }: { field_mapping?: boolean; resolve?: boolean; single?: boolean } &#x3D; {},
  ): EntityKey&lt;T&gt; | { [name: string]: any } | undefined {
    const keyTypes &#x3D; this.structuredType.keys({ include_parents: true });
    const key &#x3D; new Map&lt;string, any&gt;();
    for (const kt of keyTypes) {
      let v &#x3D; value as any;
      let options &#x3D; this as ODataModelOptions&lt;any&gt; | undefined;
      let field: ODataModelField&lt;any&gt; | undefined;
      for (const name of kt.name.split(&#x27;/&#x27;)) {
        if (options &#x3D;&#x3D;&#x3D; undefined) break;
        field &#x3D; options
          .fields({ include_navigation: false, include_parents: true })
          .find((field: ODataModelField&lt;any&gt;) &#x3D;&gt; field.field &#x3D;&#x3D;&#x3D; name);
        if (field !&#x3D;&#x3D; undefined) {
          v &#x3D; Types.isPlainObject(v) || ODataModelOptions.isModel(v) ? v[field.name] : v;
          options &#x3D; this.api.optionsForType(field.type);
        }
      }
      if (field &#x3D;&#x3D;&#x3D; undefined) return undefined;
      let name &#x3D; field_mapping ? field.field : field.name;
      if (kt.alias !&#x3D;&#x3D; undefined) name &#x3D; kt.alias;
      key.set(name, v);
    }
    if (key.size &#x3D;&#x3D;&#x3D; 0) return undefined;
    return resolve ? Objects.resolveKey(key, { single }) : Object.fromEntries(key);
  }

  resolveReferential(
    value: ODataModel&lt;T&gt; | T | { [name: string]: any } | null,
    attr: ODataModelAttribute&lt;any&gt; | ODataModelField&lt;any&gt;,
    {
      field_mapping &#x3D; false,
      resolve &#x3D; true,
      single &#x3D; false,
    }: { field_mapping?: boolean; resolve?: boolean; single?: boolean } &#x3D; {},
  ): { [name: string]: any } | null | undefined {
    const referential &#x3D; new Map&lt;string, any&gt;();
    for (const ref of attr.referentials) {
      const from &#x3D; this.fields({
        include_navigation: false,
        include_parents: true,
      }).find((p: any) &#x3D;&gt; p.field &#x3D;&#x3D;&#x3D; ref.referencedProperty);
      const to &#x3D; attr.options
        .fields({ include_navigation: false, include_parents: true })
        .find((field: ODataModelField&lt;any&gt;) &#x3D;&gt; field.field &#x3D;&#x3D;&#x3D; ref.property);
      if (from !&#x3D;&#x3D; undefined &amp;&amp; to !&#x3D;&#x3D; undefined) {
        const name &#x3D; field_mapping ? to.field : to.name;
        referential.set(name, value &amp;&amp; (value as any)[from.name]);
      }
    }
    if (referential.size &#x3D;&#x3D;&#x3D; 0) return undefined;
    if (referential.size &#x3D;&#x3D;&#x3D; 1 &amp;&amp; Array.from(referential.values())[0] &#x3D;&#x3D;&#x3D; null) return null;
    return resolve ? Objects.resolveKey(referential, { single }) : Object.fromEntries(referential);
  }

  resolveReferenced(
    value: ODataModel&lt;T&gt; | T | { [name: string]: any } | null,
    attr: ODataModelAttribute&lt;any&gt; | ODataModelField&lt;any&gt;,
    {
      field_mapping &#x3D; false,
      resolve &#x3D; true,
      single &#x3D; false,
    }: { field_mapping?: boolean; resolve?: boolean; single?: boolean } &#x3D; {},
  ): { [name: string]: any } | null | undefined {
    const referenced &#x3D; new Map&lt;string, any&gt;();
    for (const ref of attr.referentials) {
      const from &#x3D; this.fields({
        include_navigation: false,
        include_parents: true,
      }).find((field: ODataModelField&lt;any&gt;) &#x3D;&gt; field.field &#x3D;&#x3D;&#x3D; ref.property);
      const meta &#x3D; this.api.optionsForType&lt;any&gt;(attr.type);
      const to &#x3D; meta
        ?.fields({ include_navigation: false, include_parents: true })
        .find((field: ODataModelField&lt;any&gt;) &#x3D;&gt; field.field &#x3D;&#x3D;&#x3D; ref.referencedProperty);
      if (from !&#x3D;&#x3D; undefined &amp;&amp; to !&#x3D;&#x3D; undefined) {
        const name &#x3D; field_mapping ? to.field : to.name;
        referenced.set(name, value &amp;&amp; (value as any)[from.name]);
      }
    }
    if (referenced.size &#x3D;&#x3D;&#x3D; 0) return undefined;
    if (referenced.size &#x3D;&#x3D;&#x3D; 1 &amp;&amp; Array.from(referenced.values())[0] &#x3D;&#x3D;&#x3D; null) return null;
    return resolve ? Objects.resolveKey(referenced, { single }) : Object.fromEntries(referenced);
  }

  validate(
    self: ODataModel&lt;T&gt;,
    {
      method,
      navigation &#x3D; false,
    }: {
      method?: &#x27;create&#x27; | &#x27;update&#x27; | &#x27;modify&#x27;;
      navigation?: boolean;
    } &#x3D; {},
  ): { [name: string]: string[] } | undefined {
    const errors &#x3D; this.fields({
      include_parents: true,
      include_navigation: navigation,
    }).reduce((acc, field) &#x3D;&gt; {
      const value &#x3D; (self as any)[field.name];
      const errs &#x3D; field.validate(value, { method });
      return errs !&#x3D;&#x3D; undefined ? Object.assign(acc, { [field.name]: errs }) : acc;
    }, {});
    return !Types.isEmpty(errors) ? errors : undefined;
  }

  defaults(): T | { [name: string]: any } | undefined {
    const defs &#x3D; this.fields({
      include_navigation: false,
      include_parents: true,
    }).reduce((acc, field) &#x3D;&gt; {
      const value &#x3D; field.defaults();
      return value !&#x3D;&#x3D; undefined ? Object.assign(acc, { [field.name]: value }) : acc;
    }, {});
    return !Types.isEmpty(defs) ? defs : undefined;
  }

  hasChanged(
    self: ODataModel&lt;T&gt;,
    { include_navigation &#x3D; false }: { include_navigation?: boolean } &#x3D; {},
  ): boolean {
    return [...self._attributes.values()]
      .filter((attr) &#x3D;&gt; !attr.navigation || include_navigation)
      .some((attr) &#x3D;&gt; attr.isChanged({ include_navigation }));
  }

  hasKey(self: ODataModel&lt;T&gt;) {
    return this.resolveKey(self) !&#x3D;&#x3D; undefined;
  }

  withResource&lt;R, M extends ODataModel&lt;T&gt;&gt;(
    self: M,
    resource:
      | ODataEntityResource&lt;T&gt;
      | ODataPropertyResource&lt;T&gt;
      | ODataNavigationPropertyResource&lt;T&gt;
      | ODataSingletonResource&lt;T&gt;
      | null,
    ctx: (model: M) &#x3D;&gt; R,
  ): R {
    // Push
    self.pushResource(resource);
    // Execute function
    const result &#x3D; ctx(self);
    if (result instanceof Observable) {
      return (result as any).pipe(
        finalize(() &#x3D;&gt; {
          // Pop
          self.popResource();
        }),
      );
    } else {
      // Pop
      self.popResource();
      return result;
    }
  }
  asEntity&lt;R, M extends ODataModel&lt;T&gt;&gt;(self: M, ctx: (model: M) &#x3D;&gt; R): R {
    // Clone query from him or parent
    let query &#x3D; self._resource?.cloneQuery&lt;T&gt;();
    if (query &#x3D;&#x3D;&#x3D; undefined &amp;&amp; self._parent &amp;&amp; self._parent[0] instanceof ODataCollection)
      query &#x3D; self._parent[0]._resource?.cloneQuery&lt;T&gt;();
    // Build new resource
    const resource &#x3D; this.modelResourceFactory(query);
    return this.withResource(self, resource, ctx);
  }

  toEntity(
    self: ODataModel&lt;T&gt;,
    {
      client_id &#x3D; false,
      include_navigation &#x3D; false,
      include_concurrency &#x3D; false,
      include_computed &#x3D; false,
      include_key &#x3D; true,
      include_id &#x3D; false,
      include_non_field &#x3D; false,
      changes_only &#x3D; false,
      field_mapping &#x3D; false,
      chain &#x3D; [],
    }: {
      client_id?: boolean;
      include_navigation?: boolean;
      include_concurrency?: boolean;
      include_computed?: boolean;
      include_key?: boolean;
      include_id?: boolean;
      include_non_field?: boolean;
      changes_only?: boolean;
      field_mapping?: boolean;
      chain?: (ODataModel&lt;any&gt; | ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;)[];
    } &#x3D; {},
  ): T | { [name: string]: any } {
    let entity: any &#x3D; [...self._attributes.values()]
      .filter(
        // Chain
        (attr) &#x3D;&gt; chain.every((c) &#x3D;&gt; c !&#x3D;&#x3D; attr.get()),
      )
      .filter(
        // Changes only
        (attr) &#x3D;&gt; !changes_only || (changes_only &amp;&amp; attr.isChanged({ include_navigation })),
      )
      .filter(
        (attr) &#x3D;&gt;
          // Navigation
          (include_navigation &amp;&amp; attr.navigation &amp;&amp; attr.get() !&#x3D;&#x3D; null) || !attr.navigation,
      )
      .reduce((acc, attr) &#x3D;&gt; {
        const name &#x3D; field_mapping ? attr.fieldName : attr.name;
        let value: any &#x3D; attr.get();
        const computed &#x3D; attr.computed;
        const navigation &#x3D; attr.navigation;
        const concurrency &#x3D; attr.concurrency;
        if (ODataModelOptions.isModel(value)) {
          value &#x3D; (value as ODataModel&lt;any&gt;).toEntity({
            client_id,
            include_navigation,
            include_concurrency,
            include_computed,
            include_non_field,
            field_mapping,
            changes_only: changes_only &amp;&amp; !!navigation,
            include_key: include_key &amp;&amp; !!navigation,
            include_id: include_id &amp;&amp; !!navigation,
            chain: [self, ...chain],
          });
        } else if (ODataModelOptions.isCollection(value)) {
          value &#x3D; (value as ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;).toEntities({
            client_id,
            include_navigation,
            include_concurrency,
            include_computed,
            include_non_field,
            field_mapping,
            changes_only: changes_only &amp;&amp; !!navigation,
            include_key: include_key &amp;&amp; !!navigation,
            include_id: include_id &amp;&amp; !!navigation,
            chain: [self, ...chain],
          });
        }
        if (include_concurrency &amp;&amp; concurrency) {
          return Object.assign(acc, { [name]: value });
        } else if (include_computed &amp;&amp; computed) {
          return Object.assign(acc, { [name]: value });
        } else if (changes_only &amp;&amp; attr.isChanged()) {
          return Object.assign(acc, { [name]: value });
        } else if (!changes_only &amp;&amp; !concurrency &amp;&amp; !computed) {
          return Object.assign(acc, { [name]: value });
        }
        return acc;
      }, {});

    if (include_non_field) {
      const names &#x3D; Object.keys(entity);
      // Attributes from object (attributes for object)
      const nonFieldAttrs &#x3D; Object.entries(self)
        .filter(([k]) &#x3D;&gt; names.indexOf(k) &#x3D;&#x3D;&#x3D; -1 &amp;&amp; !k.startsWith(&#x27;_&#x27;) &amp;&amp; !k.endsWith(&#x27;$&#x27;))
        .reduce((acc, [k, v]) &#x3D;&gt; Object.assign(acc, { [k]: v }), {});
      entity &#x3D; { ...entity, ...nonFieldAttrs };
    }

    // Add client_id
    if (client_id) {
      (&lt;any&gt;entity)[this.cid] &#x3D; (&lt;any&gt;self)[this.cid];
    }

    // Add key
    if (include_key) {
      entity &#x3D; {
        ...entity,
        ...(this.resolveKey(self, { field_mapping, resolve: false }) as {}),
      };
    }

    // Add id
    if (include_id) {
      self.asEntity((e) &#x3D;&gt; {
        const resource &#x3D; e.resource();
        if (resource) entity[this.api.options.helper.ODATA_ID] &#x3D; &#x60;${resource.clearQuery()}&#x60;;
      });
    }

    // Add type
    if (
      self._parent !&#x3D;&#x3D; null &amp;&amp;
      ((ODataModelOptions.isModel(self._parent[0]) &amp;&amp;
        self._parent[1] !&#x3D;&#x3D; null &amp;&amp;
        this.api.optionsForType(self._parent[1].type) !&#x3D;&#x3D; self._meta) ||
        (ODataModelOptions.isCollection(self._parent[0]) &amp;&amp;
          (self._parent[0] as ODataCollection&lt;any, ODataModel&lt;any&gt;&gt;)._model.meta !&#x3D;&#x3D; self._meta))
    ) {
      entity[this.api.options.helper.ODATA_TYPE] &#x3D; &#x60;#${this.structuredType.type()}&#x60;;
    }

    return entity as T | { [name: string]: any };
  }

  reset(self: ODataModel&lt;T&gt;, { name, silent &#x3D; false }: { name?: string; silent?: boolean } &#x3D; {}) {
    let changes: string[] &#x3D; [];
    if (name !&#x3D;&#x3D; undefined) {
      // Reset value
      const attribute &#x3D; self._attributes.get(name);
      if (attribute !&#x3D;&#x3D; undefined &amp;&amp; attribute.isChanged({ include_navigation: true })) {
        attribute.reset();
        changes &#x3D; [name];
      } else if (attribute?.isChanged()) {
        attribute.reset();
        changes &#x3D; [name];
      }
    } else {
      // reset all
      changes &#x3D; [...self._attributes.keys()];
      //self._changes.clear();
      self._attributes.forEach((attr, key) &#x3D;&gt; {
        if (attr.isChanged({ include_navigation: true })) {
          attr.reset();
          changes.push(key);
        }
      });
    }
    if (!silent &amp;&amp; changes.length &gt; 0) {
      self.events$.trigger(ODataModelEventType.Reset, { options: { changes } });
    }
  }

  assign(
    self: ODataModel&lt;T&gt;,
    entity: Partial&lt;T&gt; | { [name: string]: any },
    {
      add &#x3D; true,
      merge &#x3D; true,
      remove &#x3D; true,
      reset &#x3D; false,
      reparent &#x3D; false,
      silent &#x3D; false,
    }: {
      add?: boolean;
      merge?: boolean;
      remove?: boolean;
      reset?: boolean;
      reparent?: boolean;
      silent?: boolean;
    } &#x3D; {},
  ) {
    const changes: string[] &#x3D; [];

    // Update annotations
    self.annots().update(entity);
    // Update attributes
    const attrs &#x3D; self.annots().attributes(entity, &#x27;full&#x27;);
    Object.entries(attrs)
      .filter(([, value]) &#x3D;&gt; value !&#x3D;&#x3D; undefined) // Filter undefined
      .forEach(([key, value]) &#x3D;&gt; {
        const field &#x3D; this.findField(key, { reset });

        if (field !&#x3D;&#x3D; undefined || this.isOpenType()) {
          // Delegated to private setter
          if (
            this.set(self, field ?? key, value, {
              add,
              merge,
              remove,
              reset,
              reparent,
              silent,
            })
          ) {
            changes.push(field?.name ?? key);
          }
        } else {
          // Basic assignment
          const current &#x3D; (&lt;any&gt;self)[key];
          (&lt;any&gt;self)[key] &#x3D; value;
          if (current !&#x3D;&#x3D; value) changes.push(key);
        }
      });

    if (!silent &amp;&amp; changes.length &gt; 0) {
      self.events$.trigger(reset ? ODataModelEventType.Reset : ODataModelEventType.Update, {
        options: { changes },
      });
    }
    return self;
  }

  static isModel(obj: any) {
    return Types.rawType(obj) &#x3D;&#x3D;&#x3D; &#x27;Model&#x27;;
  }

  static isCollection(obj: any) {
    return Types.rawType(obj) &#x3D;&#x3D;&#x3D; &#x27;Collection&#x27;;
  }

  get&lt;F&gt;(
    self: ODataModel&lt;T&gt;,
    field: ODataModelField&lt;F&gt; | string,
  ): F | ODataModel&lt;F&gt; | ODataCollection&lt;F, ODataModel&lt;F&gt;&gt; | null | undefined {
    const attr &#x3D; self._attributes.get(field instanceof ODataModelField ? field.name : field);
    if (attr !&#x3D;&#x3D; undefined) {
      const value &#x3D; attr.get();
      if ((attr.navigation &amp;&amp; value &#x3D;&#x3D;&#x3D; null) || ODataModelOptions.isModel(value)) {
        // Check for reference
        const referenced &#x3D; this.resolveReferenced(self, attr, {
          resolve: false,
        });
        if (value !&#x3D;&#x3D; null &amp;&amp; referenced !&#x3D;&#x3D; null &amp;&amp; referenced !&#x3D;&#x3D; undefined) {
          (value as ODataModel&lt;F&gt;).assign(referenced as Partial&lt;F&gt;, {
            silent: true,
          });
        } else if (value !&#x3D;&#x3D; null &amp;&amp; referenced &#x3D;&#x3D;&#x3D; null) {
          // New value is null
          (attr as ODataModelAttribute&lt;F&gt;).set(null);
        } else if (value &#x3D;&#x3D;&#x3D; null &amp;&amp; referenced !&#x3D;&#x3D; null) {
          // New value is undefined
          (attr as ODataModelAttribute&lt;F&gt;).set(undefined);
        }
      }
      return value;
    } else if (typeof field &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; !field.startsWith(&#x27;_&#x27;) &amp;&amp; !field.endsWith(&#x27;$&#x27;)) {
      return (self as any)[field];
    }
    return undefined;
  }

  set&lt;F&gt;(
    self: ODataModel&lt;T&gt;,
    field: ODataModelField&lt;F&gt; | string,
    value:
      | F
      | F[]
      | { [name: string]: any }
      | { [name: string]: any }[]
      | ODataModel&lt;F&gt;
      | ODataCollection&lt;F, ODataModel&lt;F&gt;&gt;
      | null,
    {
      add,
      merge,
      remove,
      reset,
      reparent,
      silent,
      type,
    }: {
      add?: boolean;
      merge?: boolean;
      remove?: boolean;
      reset?: boolean;
      reparent?: boolean;
      silent?: boolean;
      type?: EdmType | string;
    } &#x3D; {},
  ): boolean {
    let modelField &#x3D; field instanceof ODataModelField ? field : this.findField&lt;F&gt;(field);
    if (modelField &#x3D;&#x3D;&#x3D; undefined &amp;&amp; this.isOpenType() &amp;&amp; typeof field &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
      type &#x3D; type ?? this.tsToEdm[typeof value] ?? EdmType.String;
      modelField &#x3D; this.modelFieldFactory&lt;F&gt;(self, field, type);
    }
    if (modelField &#x3D;&#x3D;&#x3D; undefined) throw new Error(&#x60;No field with name ${field as string}&#x60;);

    let changed &#x3D; false;
    let attr &#x3D; self._attributes.get(modelField.name);

    // Ensures that the attribute exists
    if (attr &#x3D;&#x3D;&#x3D; undefined) {
      attr &#x3D; new ODataModelAttribute(self, modelField);
      this._link(self, attr);
      self._attributes.set(modelField.name, attr);
    }

    const current &#x3D; attr.get();

    if (modelField.isStructuredType()) {
      if (value &#x3D;&#x3D;&#x3D; null) {
        // New value is null
        changed &#x3D; attr.set(value as null, reset, reparent);
      } else if (ODataModelOptions.isCollection(current)) {
        // Current is collection
        const currentCollection &#x3D; current as ODataCollection&lt;F, ODataModel&lt;F&gt;&gt;;
        if (ODataModelOptions.isCollection(value)) {
          // New value is collection
          changed &#x3D; attr.set(value as ODataCollection&lt;F, ODataModel&lt;F&gt;&gt;, reset, reparent);
        } else if (Types.isArray(value)) {
          // New value is array
          currentCollection._annotations &#x3D; modelField.annotationsFactory(
            self.annots(),
          ) as ODataEntitiesAnnotations&lt;F&gt;;
          currentCollection.assign(value as Partial&lt;T&gt;[] | { [name: string]: any }[], {
            add,
            merge,
            remove,
            reset,
            reparent,
            silent,
          });
          changed &#x3D; currentCollection.hasChanged();
        }
      } else if (ODataModelOptions.isModel(current)) {
        // Current is model
        const currentModel &#x3D; current as ODataModel&lt;F&gt;;
        if (ODataModelOptions.isModel(value)) {
          // New value is model
          changed &#x3D; attr.set(value as ODataModel&lt;F&gt;, reset, reparent);
        } else if (Types.isPlainObject(value)) {
          currentModel._annotations &#x3D; modelField.annotationsFactory(
            self.annots(),
          ) as ODataEntityAnnotations&lt;F&gt;;
          currentModel.assign(value as F | { [name: string]: any }, {
            add,
            merge,
            remove,
            reset,
            reparent,
            silent,
          });
          changed &#x3D; currentModel.hasChanged();
        }
      } else {
        // Current is null or undefined
        // create new model/collection for given value
        changed &#x3D; attr.set(
          ODataModelOptions.isCollection(value) || ODataModelOptions.isModel(value)
            ? (value as ODataModel&lt;F&gt; | ODataCollection&lt;F, ODataModel&lt;F&gt;&gt;)
            : modelField.collection
              ? modelField.collectionFactory&lt;F&gt;({
                  parent: self,
                  value: value as F[] | { [name: string]: any }[],
                  reset: reset,
                })
              : modelField.modelFactory&lt;F&gt;({
                  parent: self,
                  value: value,
                  reset: reset,
                }),
          reset,
          reparent,
        );
      }

      // Resolve referentials
      if (!ODataModelOptions.isCollection(attr.get())) {
        const meta &#x3D; this.api.optionsForType&lt;F&gt;(modelField.type);
        const ref &#x3D; meta?.resolveReferential(attr.get(), attr, {
          resolve: false,
        });
        if (ref !&#x3D;&#x3D; null &amp;&amp; ref !&#x3D;&#x3D; undefined) {
          Object.assign(self, ref);
        }
      }
    } else {
      changed &#x3D; attr.set(value, reset, reparent);
    }

    if (!silent &amp;&amp; changed) {
      self.events$.trigger(ODataModelEventType.Change, {
        attr,
        value,
        previous: current,
        options: { key: modelField.isKey() },
      });
    }

    return changed;
  }

  private _link&lt;F&gt;(self: ODataModel&lt;T&gt;, attr: ODataModelAttribute&lt;F&gt;) {
    attr.events$.subscribe((event: ODataModelEvent&lt;any&gt;) &#x3D;&gt; {
      if (event.canContinueWith(self)) {
        if (event.model &#x3D;&#x3D;&#x3D; attr.get()) {
          if (event.type &#x3D;&#x3D;&#x3D; ODataModelEventType.Change &amp;&amp; attr.navigation &amp;&amp; event.options?.key) {
            const ref &#x3D; (attr.get() as ODataModel&lt;any&gt;).referential(attr);
            if (ref !&#x3D;&#x3D; null &amp;&amp; ref !&#x3D;&#x3D; undefined) {
              Object.assign(self, ref);
            }
          }
        }

        self.events$.emit(event.push(self, attr));
      }
    });
  }
}
</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'ODataModelEvent.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
